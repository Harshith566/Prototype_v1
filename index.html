<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="user-scalable=no">
<title>volumeshader_bm Â· peak limit</title>
<style>
body { background:#131115; margin:0; overflow:hidden; }
#c1 { background:#fbf7fe; display:block; }
#main { transform-origin:0 0; position:fixed; left:0; top:0; }
</style>
</head>

<body>
<div id="main">
<canvas id="c1" width="1024" height="1024"></canvas>
</div>

<script>

let cx, cy, canvas, gl;
let glposition, glright, glforward, glup, glorigin, glx, gly, gllen;

let len=1.6, ang1=2.8, ang2=0.4;
let cenx=0, ceny=0, cenz=0;
let mx=0,my=0,ml=0,mr=0;

/////////////////////////
// PEAK SAFE KERNEL
/////////////////////////

const KERNEL = `
float kernal(vec3 ver){
    vec3 a = ver;
    float b,c,d;

    for(int i=0;i<12;i++){        // peak-safe iteration count

        b = length(a);
        b = max(b,1e-6);          // NaN guard

        c = atan(a.y,a.x)*65.0;
        d = acos(clamp(a.z/b,-1.0,1.0))*65.0;

        b = pow(b,10.0 + sin(b*14.0)*1.8);

        a = vec3(
            b*sin(d)*cos(c),
            b*sin(d)*sin(c),
            b*cos(d)
        );

        // heavy warp (stable)
        a += sin(a*8.0)*0.25;
        a.xy *= mat2(cos(b),-sin(b),sin(b),cos(b));

        a += ver;

        if(b>8.0) break;
    }

    return 5.0 - dot(a,a*vec3(1.0,1.2,1.2))
           + sin(a.x*40.0)*0.8
           + cos(a.y*40.0)*0.8
           + sin(a.z*50.0)*0.8;
}
`;

/////////////////////////
// SHADERS
/////////////////////////

const VSHADER = `
precision highp float;
attribute vec4 position;
varying vec3 dir, localdir;
uniform vec3 right,forward,up;
uniform float x,y;

void main(){
    gl_Position = position;
    dir = forward + right*position.x*x + up*position.y*y;
    localdir = vec3(position.x*x,position.y*y,-1.0);
}
`;

const FSHADER = `
precision highp float;
#define MAXR 8
#define SOLVER 8

float kernal(vec3 ver);

uniform vec3 right,forward,up,origin;
varying vec3 dir, localdir;
uniform float len;

const float step = 0.0010;   // finer sampling

void main(){

    vec3 color=vec3(0.0);
    float v1=kernal(origin+dir*(step*len));
    float v2=kernal(origin);

    float r1,r2,r3;
    float m1,m2,m3;
    vec3 ver,n,reflect;

    int sign=0;

    for(int k=2;k<3300;k++){   // watchdog edge

        ver=origin+dir*(step*len*float(k));
        float v=kernal(ver);

        if(v>0.0 && v1<0.0){

            r1=step*len*float(k-1);
            r2=step*len*float(k);

            for(int i=0;i<SOLVER;i++){
                r3=0.5*(r1+r2);
                m3=kernal(origin+dir*r3);
                if(m3>0.0) r2=r3; else r1=r3;
            }

            sign=1;
            break;
        }

        v2=v1;
        v1=v;
    }

    if(sign==1){

        ver=origin+dir*r3;

        n.x=kernal(ver-right*(r3*0.00025))
            -kernal(ver+right*(r3*0.00025));

        n.y=kernal(ver-up*(r3*0.00025))
            -kernal(ver+up*(r3*0.00025));

        n.z=kernal(ver+forward*(r3*0.00025))
            -kernal(ver-forward*(r3*0.00025));

        n=normalize(n);

        vec3 v=normalize(localdir);
        reflect=n*(-2.0*dot(v,n))+v;

        float light=max(dot(reflect,vec3(.276,.920,.276)),0.0);
        light=pow(light,4.0)*0.45
              +dot(n,vec3(.276,.920,.276))*0.25
              +0.3;

        float r=dot(ver,ver);

        vec3 base=vec3(
            sin(r*20.0)*0.7+0.8,
            sin(r*20.0+2.05)*0.7+0.8,
            sin(r*20.0-2.05)*0.7+0.8
        );

        color=base*light;
    }

    gl_FragColor=vec4(color,1.0);
}
`;

/////////////////////////
// INIT
/////////////////////////

function compile(type,src){
    let s=gl.createShader(type);
    gl.shaderSource(s,src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))
        throw gl.getShaderInfoLog(s);
    return s;
}

function init(){

    canvas=document.getElementById("c1");
    gl=canvas.getContext("webgl");

    let prog=gl.createProgram();
    gl.attachShader(prog,compile(gl.VERTEX_SHADER,VSHADER));
    gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,FSHADER+KERNEL));
    gl.linkProgram(prog);

    gl.useProgram(prog);

    glposition=gl.getAttribLocation(prog,"position");
    glright=gl.getUniformLocation(prog,"right");
    glforward=gl.getUniformLocation(prog,"forward");
    glup=gl.getUniformLocation(prog,"up");
    glorigin=gl.getUniformLocation(prog,"origin");
    glx=gl.getUniformLocation(prog,"x");
    gly=gl.getUniformLocation(prog,"y");
    gllen=gl.getUniformLocation(prog,"len");

    let buf=gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER,buf);
    gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([
        -1,-1,0,1,-1,0,1,1,0,
        -1,-1,0,1,1,0,-1,1,0]),gl.STATIC_DRAW);

    gl.vertexAttribPointer(glposition,3,gl.FLOAT,false,0,0);
    gl.enableVertexAttribArray(glposition);

    resize();
    requestAnimationFrame(loop);
}

/////////////////////////
// RENDER LOOP
/////////////////////////

function loop(){

    ang1+=0.01;

    gl.uniform1f(glx,cx*2/(cx+cy));
    gl.uniform1f(gly,cy*2/(cx+cy));
    gl.uniform1f(gllen,len);

    gl.uniform3f(glorigin,
        len*Math.cos(ang1)*Math.cos(ang2)+cenx,
        len*Math.sin(ang2)+ceny,
        len*Math.sin(ang1)*Math.cos(ang2)+cenz);

    gl.uniform3f(glright,Math.sin(ang1),0,-Math.cos(ang1));
    gl.uniform3f(glup,
        -Math.sin(ang2)*Math.cos(ang1),
        Math.cos(ang2),
        -Math.sin(ang2)*Math.sin(ang1));

    gl.uniform3f(glforward,
        -Math.cos(ang1)*Math.cos(ang2),
        -Math.sin(ang2),
        -Math.sin(ang1)*Math.cos(ang2));

    gl.drawArrays(gl.TRIANGLES,0,6);

    requestAnimationFrame(loop);
}

/////////////////////////
// RESIZE
/////////////////////////

function resize(){
    cx=innerWidth;
    cy=innerHeight;
    let s=Math.min(cx,cy);
    main.style.transform=`scale(${s/1024})`;
}

window.onresize=resize;
window.onload=init;

</script>
</body>
</html>
