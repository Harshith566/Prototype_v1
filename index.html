<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Stable GPU Beast</title>
<style>
body { margin:0; overflow:hidden; background:black; }
canvas { display:block; width:100vw; height:100vh; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");

// Try WebGL
let gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");

if (!gl) {
    document.body.innerHTML = "<h1 style='color:white;text-align:center'>WebGL Not Supported</h1>";
    throw new Error("WebGL not supported");
}

// Safe resolution detection
const maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);

// Use safe internal resolution
const targetWidth = Math.min(1920, maxSize);
const targetHeight = Math.min(1080, maxSize);

canvas.width = targetWidth;
canvas.height = targetHeight;

gl.viewport(0, 0, canvas.width, canvas.height);

// Fullscreen quad
const vertices = new Float32Array([
-1,-1, 1,-1, 1,1,
-1,-1, 1,1, -1,1
]);

// Vertex Shader
const vsSource = `
attribute vec2 position;
varying vec2 uv;
void main(){
    uv = position;
    gl_Position = vec4(position,0.0,1.0);
}
`;

// Heavy Fragment Shader (but safe)
const fsSource = `
precision highp float;
varying vec2 uv;
uniform float time;

float fractal(vec3 p){
    vec3 z = p;
    float scale = 1.0;
    float total = 0.0;
    for(int i=0;i<64;i++){
        z = abs(z)/dot(z,z) - 0.7;
        float l = length(z);
        total += exp(-l*10.0) * scale;
        scale *= 0.95;
    }
    return total;
}

void main(){
    vec2 coord = uv;
    vec3 dir = normalize(vec3(coord, -1.5));
    vec3 origin = vec3(0.0,0.0,4.0);

    float angle = time*0.3;
    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
    dir.xz = rot * dir.xz;
    origin.xz = rot * origin.xz;

    vec3 color = vec3(0.0);
    float t = 0.0;

    for(int i=0;i<128;i++){
        vec3 p = origin + dir * t;
        float d = fractal(p);
        color += vec3(
            sin(d*5.0),
            cos(d*7.0),
            sin(d*11.0)
        ) * 0.02;
        t += 0.02;
    }

    gl_FragColor = vec4(abs(color),1.0);
}
`;

// Compile helper
function compile(type, source){
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
        console.error(gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
}

const vs = compile(gl.VERTEX_SHADER, vsSource);
const fs = compile(gl.FRAGMENT_SHADER, fsSource);

const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);

if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(program));
}

gl.useProgram(program);

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

const position = gl.getAttribLocation(program, "position");
gl.enableVertexAttribArray(position);
gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

const timeLoc = gl.getUniformLocation(program, "time");

// Animation
function render(t){
    gl.uniform1f(timeLoc, t*0.001);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(render);
}

requestAnimationFrame(render);
</script>
</body>
</html>